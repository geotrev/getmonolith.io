@function str-replace($string, $search, $replace: "") {
  $index: str-index($string, $search);

  @if $index {
    @return str-slice($string, 1, $index - 1) + $replace +
      str-replace(str-slice($string, $index + str-length($search)), $search, $replace);
  }

  @return $string;
}

@mixin set-flow($property, $value) {
  $rtl-property: $property;
  $rtl-value: $value;

  @if type-of($value) == string {
    @if str-index($value, "left") {
      $rtl-value: str-replace($value, "left", "right");
    } @else if str-index($value, "right") {
      $rtl-value: str-replace($value, "right", "left");
    }
  }

  @if str-index($property, "left") {
    $rtl-property: str-replace($property, "left", "right");
  } @else if str-index($property, "right") {
    $rtl-property: str-replace($property, "right", "left");
  }

  html:not([dir="rtl"]) & {
    #{$property}: $value;
  }

  html[dir="rtl"] & {
    #{$rtl-property}: $rtl-value;
  }
}

@mixin grid-classes($size) {
  @for $i from 1 through $columns {
    .#{$size}-#{$i} {
      flex: 0 0 percentage($i / $columns);
      max-width: percentage($i / $columns);
    }

    @if $column-offset-classes == true {
      .#{$size}-offset-#{$i} {
        @include set-flow("margin-left", percentage($i / $columns));
      }
    }

    @if $column-order-classes == true {
      // order-1 = -12
      // order-2 = -11
      // etc...
      .#{$size}-order-#{$i} {
        order: $i - 1 - $columns;
      }
    }
  }
}

@mixin breakpoint-up($size) {
  @media screen and (min-width: #{breakpoint($size)}) {
    @content;
  }
}

@mixin breakpoint-down($size) {
  @media screen and (max-width: #{breakpoint($size) - 1}) {
    @content;
  }
}

@mixin breakpoint-between($min, $max) {
  @media screen
    and (min-width: #{breakpoint($min)})
    and (max-width: #{breakpoint($max) - 1}) {
    @content;
  }
}

@mixin header-sizes($headers) {
  @each $header, $properties in $headers {
    #{$header},
    .#{$header} {
      @each $property, $value in $properties {
        #{$property}: $value;
      }
    }
  }
}

// this mixin is used for arrow mixins/CSS below and in src/scss/components/_dropdown.scss
@mixin if-has-arrow {
  &:not(.has-no-arrow) {
    @content;
  }
}

// These values calculate a consistent arrow fill (inner) and arrow border (outer),
// given any value of $arrow-size from _config.scss
// partial pixel values are used to prevent some browsers from clipping the edge
$arrow-fill-position: $arrow-size * -2 + 1.5px;
$arrow-border-position: $arrow-size * -2;

@mixin arrow-base {
  @include set-flow("border-left", $arrow-size solid transparent);
  @include set-flow("border-right", $arrow-size solid transparent);
  border-bottom: $arrow-size solid transparent;
  border-top: $arrow-size solid transparent;
  content: "";
  position: absolute;
}

@mixin up-arrow($edge-offset, $fill-color, $border-color) {
  @include if-has-arrow {
    &::after {
      @include arrow-base;
      @include set-flow("left", $edge-offset);
      @include set-flow("right", auto);
      top: $arrow-fill-position;
      bottom: auto;
      border-bottom: $arrow-size solid $fill-color;
    }

    &::before {
      @include arrow-base;
      @include set-flow("left", $edge-offset);
      @include set-flow("right", auto);
      top: $arrow-border-position;
      bottom: auto;
      border-bottom: $arrow-size solid $border-color;
    }
  }
}

@mixin down-arrow($edge-offset, $fill-color, $border-color) {
  @include if-has-arrow {
    &::after {
      @include arrow-base;
      @include set-flow("left", $edge-offset);
      @include set-flow("right", auto);
      bottom: $arrow-fill-position;
      top: auto;
      border-top: $arrow-size solid $fill-color;
    }

    &::before {
      @include arrow-base;
      @include set-flow("left", $edge-offset);
      @include set-flow("right", auto);
      bottom: $arrow-border-position;
      top: auto;
      border-top: $arrow-size solid $border-color;
    }
  }
}

@mixin right-arrow($edge-offset, $fill-color, $border-color) {
  @include if-has-arrow {
    &::after {
      @include arrow-base;
      @include set-flow("border-left", $arrow-size solid $fill-color);
      @include set-flow("right", $arrow-fill-position);
      @include set-flow("left", auto);
      top: $edge-offset;
      bottom: auto;
    }

    &::before {
      @include arrow-base;
      @include set-flow("border-left", $arrow-size solid $border-color);
      @include set-flow("right", $arrow-border-position);
      @include set-flow("left", auto);
      top: $edge-offset;
      bottom: auto;
    }
  }
}

@mixin left-arrow($edge-offset, $fill-color, $border-color) {
  @include if-has-arrow {
    &::after {
      @include arrow-base;
      @include set-flow("border-right", $arrow-size solid $fill-color);
      @include set-flow("left", $arrow-fill-position);
      @include set-flow("right", auto);
      top: $edge-offset;
      bottom: auto;
    }

    &::before {
      @include arrow-base;
      @include set-flow("border-right", $arrow-size solid $border-color);
      @include set-flow("left", $arrow-border-position);
      @include set-flow("right", auto);
      top: $edge-offset;
      bottom: auto;
    }
  }
}

@mixin visibility($size) {
  .has-display-flex-#{$size} {
    display: flex !important;
  }

  .has-display-block-#{$size} {
    display: block !important;
  }

  .has-display-none-#{$size} {
    display: none !important;
  }
}

@mixin input-field-base-properties {
  background: $input-background;
  appearance: none;
  border-radius: $input-border-radius;
  border: $input-border;
  box-shadow: $input-box-shadow;
  font-family: $input-font-family;
  font-size: $input-font-size;
  margin: $input-margin;
  padding: $input-padding;
}

@mixin input-field-interacted-properties {
  transition: $global-transition;

  &:focus,
  &:active {
    background: $input-focus-background !important;
    border: $input-focus-border !important;
    box-shadow: $input-focus-box-shadow !important;
  }

  &:hover {
    background: $input-hover-background;
    border: $input-hover-border;
    box-shadow: $input-hover-box-shadow;
    transition: $global-transition;
  }
}

@mixin input-element-disabled-properties {
  background: $input-disabled-background !important;
  border: $input-disabled-border !important;
  color: $input-disabled-color !important;
  cursor: not-allowed;
  resize: $input-disabled-resize !important;
  opacity: 1;

  &:hover {
    background: $input-disabled-background !important;
    border: $input-disabled-border !important;
    color: $input-disabled-color !important;
  }
}

@mixin input-of-type-disabled($type) {
  input[type="#{$type}"]:disabled,
  input[type="#{$type}"].disabled {
    @include input-element-disabled-properties;
  }
}

@mixin no-scroll {
  .no-scroll {
    overflow: hidden !important;
  }
}

@mixin using-keyboard {
  $inputs: "";

  @each $type in $input-field-types {
    $inputs: $inputs + ':not([type="#{$type}"])';
  }

  .using-keyboard *#{$inputs}:not(textarea):not(select):focus {
    outline: $global-outline-using-keyboard !important;
  }
}
